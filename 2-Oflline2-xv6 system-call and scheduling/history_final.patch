diff --git a/Makefile b/Makefile
index f8c820e..f6f0373 100644
--- a/Makefile
+++ b/Makefile
@@ -139,6 +139,7 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_history\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
@@ -159,9 +160,12 @@ GDBPORT = $(shell expr `id -u` % 5000 + 25000)
 QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
-ifndef CPUS
-CPUS := 3
-endif
+# ifndef CPUS
+# CPUS := 3
+# endif
+
+## Dont forget to make it 3 when multi processors
+CPUS := 1
 
 QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
 QEMUOPTS += -global virtio-mmio.force-legacy=false
diff --git a/kernel/defs.h b/kernel/defs.h
index d1b6bb9..9db2499 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -106,6 +106,9 @@ void            yield(void);
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
+// My codes
+void            init_histories(void);
+int             history(void);
 
 // swtch.S
 void            swtch(struct context*, struct context*);
@@ -187,3 +190,6 @@ void            virtio_disk_intr(void);
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+
+// My codes
+// Ofline2_task1
diff --git a/kernel/history_info.h b/kernel/history_info.h
new file mode 100644
index 0000000..03ea519
--- /dev/null
+++ b/kernel/history_info.h
@@ -0,0 +1,5 @@
+struct history_info {
+    char syscall_name [16];
+    int count ;
+    int accum_time ;
+};
\ No newline at end of file
diff --git a/kernel/main.c b/kernel/main.c
index f0d3171..4047dde 100644
--- a/kernel/main.c
+++ b/kernel/main.c
@@ -29,6 +29,9 @@ main()
     fileinit();      // file table
     virtio_disk_init(); // emulated hard disk
     userinit();      // first user process
+    // My code
+    init_histories();
+
     __sync_synchronize();
     started = 1;
   } else {
diff --git a/kernel/param.h b/kernel/param.h
index 80ec6d3..6d05f8b 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -13,3 +13,7 @@
 #define MAXPATH      128   // maximum file path name
 #define USERSTACK    1     // user stack pages
 
+
+
+// My codes
+#define NSYSCALLS 22
diff --git a/kernel/proc.c b/kernel/proc.c
index 130d9ce..efcb8c7 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -6,6 +6,11 @@
 #include "proc.h"
 #include "defs.h"
 
+
+//My codes
+#include "history_info.h"
+#include "syscall.h"
+
 struct cpu cpus[NCPU];
 
 struct proc proc[NPROC];
@@ -20,6 +25,38 @@ static void freeproc(struct proc *p);
 
 extern char trampoline[]; // trampoline.S
 
+
+// My codes
+struct history_info all_histories[NSYSCALLS];
+
+char *syscall_names[] = {
+  [SYS_fork]    = "fork",
+  [SYS_exit]    = "exit",
+  [SYS_wait]    = "wait",
+  [SYS_pipe]    = "pipe",
+  [SYS_read]    = "read",
+  [SYS_kill]    = "kill",
+  [SYS_exec]    = "exec",
+  [SYS_fstat]   = "fstat",
+  [SYS_chdir]   = "chdir",
+  [SYS_dup]     = "dup",
+  [SYS_getpid]  = "getpid",
+  [SYS_sbrk]    = "sbrk",
+  [SYS_sleep]   = "sleep",
+  [SYS_uptime]  = "uptime",
+  [SYS_open]    = "open",
+  [SYS_write]   = "write",
+  [SYS_mknod]   = "mknod",
+  [SYS_unlink]  = "unlink",
+  [SYS_link]    = "link",
+  [SYS_mkdir]   = "mkdir",
+  [SYS_close]   = "close",
+  [SYS_history] = "history"
+};
+
+
+
+
 // helps ensure that wakeups of wait()ing
 // parents are not lost. helps obey the
 // memory model when using p->parent.
@@ -693,3 +730,34 @@ procdump(void)
     printf("\n");
   }
 }
+
+
+
+
+
+
+//My codes
+
+void 
+init_histories(void){
+  for( int i=0; i<NSYSCALLS; i++)
+  {
+      safestrcpy(all_histories[i].syscall_name, syscall_names[i+1], sizeof(all_histories[i].syscall_name));
+      all_histories[i].count = 0;
+      all_histories[i].accum_time = 0;
+  }
+}
+
+
+int 
+history(void){
+  int sys_num;
+  argint(0, &sys_num);
+
+  uint64 hptr;
+  argaddr(1, &hptr);
+
+  struct history_info ht = all_histories[sys_num-1];
+  copyout( myproc()->pagetable, hptr, (char *) &ht, sizeof(ht));
+  return 0;
+}
\ No newline at end of file
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..bf2e180 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -6,6 +6,12 @@
 #include "proc.h"
 #include "syscall.h"
 #include "defs.h"
+#include "history_info.h"
+
+
+// My codes
+struct spinlock modify_lock;
+
 
 // Fetch the uint64 at addr from the current process.
 int
@@ -101,6 +107,10 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_history(void);
+
+
+extern struct history_info all_histories[];
 
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
@@ -126,6 +136,7 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_history] sys_history,
 };
 
 void
@@ -136,9 +147,19 @@ syscall(void)
 
   num = p->trapframe->a7;
   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+
+    uint tick_before = ticks;
+
     // Use num to lookup the system call function for num, call it,
     // and store its return value in p->trapframe->a0
     p->trapframe->a0 = syscalls[num]();
+    uint tick_after = ticks;
+
+    acquire(&modify_lock);
+    all_histories[num-1].accum_time += (tick_after-tick_before);
+    all_histories[num-1].count++;
+    release(&modify_lock);
+  
   } else {
     printf("%d %s: unknown sys call %d\n",
             p->pid, p->name, num);
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..a4211eb 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,6 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+
+// My SYS IDs
+#define SYS_history 22
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 3b4d5bd..c65dc8b 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -91,3 +91,11 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+
+
+uint64 
+sys_history(void)
+{
+  return history();
+}
\ No newline at end of file
diff --git a/user/history.c b/user/history.c
new file mode 100644
index 0000000..4339f4d
--- /dev/null
+++ b/user/history.c
@@ -0,0 +1,47 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+
+#include "kernel/param.h"
+#include "kernel/history_info.h"
+#include "user/user.h"
+
+
+int
+main(int argc, char *argv[])
+{
+    if( argc != 1 && argc != 2 ){
+        printf("Usage history <system number>");
+        return 0;
+    }
+
+
+    int sys_num;
+    struct history_info ht;
+
+    if( argc == 2 ){
+        sys_num = atoi(argv[1]);
+        // printf("sys_num : %d\n", sys_num);
+
+        int check = history( sys_num, &ht );
+        if(check){
+            printf("Something wrong happened!");
+            return 0;
+        }
+
+        printf("%d: syscall: %s, #: %d, time: %d\n", sys_num, ht.syscall_name, ht.count, ht.accum_time);
+    }
+    else if ( argc == 1 ){
+        printf("Printing all history\n");
+
+        for( int i = 1; i<=NSYSCALLS; i++){
+            int check = history( i, &ht );
+            if(check){
+                printf("Something wrong happened!");
+                return 0;
+            }
+
+            printf("%d: syscall: %s, #: %d, time: %d\n", i, ht.syscall_name, ht.count, ht.accum_time);
+        }
+    }
+    
+}
diff --git a/user/user.h b/user/user.h
index f16fe27..f85c1ea 100644
--- a/user/user.h
+++ b/user/user.h
@@ -1,5 +1,8 @@
 struct stat;
 
+//My structs
+struct history_info;
+
 // system calls
 int fork(void);
 int exit(int) __attribute__((noreturn));
@@ -23,6 +26,10 @@ char* sbrk(int);
 int sleep(int);
 int uptime(void);
 
+//My calls
+int history(int, struct history_info*);
+
+
 // ulib.c
 int stat(const char*, struct stat*);
 char* strcpy(char*, const char*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..9d54e5b 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,4 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("history");
